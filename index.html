<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>3D Network Background Example</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- 구글 폰트 예시(선택) -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000; /* 검정색 배경 */
      overflow: hidden; /* 스크롤바 숨김 */
      font-family: 'Merriweather', serif;
      color: #fff;
    }

    /* 메인 콘텐츠(원한다면 추가) */
    .content {
      position: relative;
      z-index: 10; /* 배경 캔버스보다 위로 */
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <!-- 실제 내용 영역 (원한다면) -->
  <div class="content">
    <h1>Distributed Intelligence &amp; System Laboratory</h1>
    <p>Three.js 애니메이션 배경 예시</p>
  </div>

  <!-- three.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

  <script>
    let scene, camera, renderer;
    let mesh, geometry;
    let clock = new THREE.Clock();

    function init() {
      // 1) 장면(씬) 만들기
      scene = new THREE.Scene();

      // 2) 카메라
      camera = new THREE.PerspectiveCamera(
        75, // 시야각
        window.innerWidth / window.innerHeight, // 종횡비
        0.1, // near
        1000 // far
      );
      camera.position.z = 45; // 카메라를 뒤로 배치

      // 3) 렌더러
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 4) 지오메트리(평면) + 머티리얼(와이어프레임)
      //    세분화가 많을수록 그물망이 촘촘
      geometry = new THREE.PlaneGeometry(60, 30, 60, 30);

      // 여러 색상(초록/빨강)을 혼합하는 방법 (vertexColors) 예시
      // 각 버텍스마다 색을 할당해보자.
      const colorGreen = new THREE.Color(0x00ff00);
      const colorRed   = new THREE.Color(0xff0000);
      const verticesCount = geometry.attributes.position.count;

      // geometry에 Color attribute 추가
      const colors = [];
      for (let i = 0; i < verticesCount; i++) {
        // 절반은 초록, 절반은 빨강 or 무작위
        // 여기서는 x 좌표에 따라 색을 섞어봄
        const x = geometry.attributes.position.getX(i);
        // -30 ~ 30 범위 가정 -> 0~1로 매핑
        const ratio = (x + 30) / 60; 
        // color.lerpColors( color1, color2, alpha )로 중간색
        const c = new THREE.Color();
        c.lerpColors(colorGreen, colorRed, ratio);
        colors.push(c.r, c.g, c.b);
      }
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      // 머티리얼에 vertexColors: true 설정
      const material = new THREE.MeshBasicMaterial({
        wireframe: true,
        vertexColors: true // 버텍스 색상 사용
      });

      mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI / 2; // 평면을 위로 세움
      scene.add(mesh);

      // 5) 애니메이션 루프 시작
      animate();

      // 리사이즈 이벤트
      window.addEventListener('resize', onWindowResize);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();
      // geometry 속성 업데이트
      // vertex를 살짝 흔들어 네트처럼 움직이는 느낌
      const positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        // 예시: x, y, time을 이용해 물결 모양
        const wave = Math.sin(x * 0.5 + time * 2) + Math.cos(y * 0.3 + time * 1.5);
        positions.setZ(i, wave * 0.8);
      }
      positions.needsUpdate = true;

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
